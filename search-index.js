var searchIndex = {};
searchIndex['glob'] = {"items":[[0,"","glob","Support for matching file paths against Unix shell style patterns."],[1,"Paths","","An iterator that yields Paths from the filesystem that match a particular\npattern - see the `glob` function for more details."],[1,"Pattern","","A compiled Unix shell style pattern."],[1,"MatchOptions","","Configuration options to modify the behaviour of `Pattern::matches_with(..)`"],[11,"case_sensitive","","Whether or not patterns should be matched in a case-sensitive manner. This\ncurrently only considers upper/lower case relationships between ASCII characters,\nbut in future this might be extended to work with Unicode.",0],[11,"require_literal_separator","","If this is true then path-component separator characters (e.g. `/` on Posix)\nmust be matched by a literal `/`, rather than by `*` or `?` or `[...]`",0],[11,"require_literal_leading_dot","","If this is true then paths that contain components that start with a `.` will\nnot match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\nwill not match. This is useful because such files are conventionally considered\nhidden on Unix systems and it might be desirable to skip them when listing files.",0],[3,"glob","","Return an iterator that produces all the Paths that match the given pattern,\nwhich may be absolute or relative to the current working directory."],[3,"glob_with","","Return an iterator that produces all the Paths that match the given pattern,\nwhich may be absolute or relative to the current working directory."],[10,"next","","",1],[10,"default","","",2],[10,"hash","","",2],[10,"cmp","","",2],[10,"partial_cmp","","",2],[10,"lt","","",2],[10,"le","","",2],[10,"gt","","",2],[10,"ge","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"clone","","",2],[10,"new","","This function compiles Unix shell style patterns: `?` matches any single\ncharacter, `*` matches any (possibly empty) sequence of characters and\n`[...]` matches any character inside the brackets, unless the first\ncharacter is `!` in which case it matches any character except those\nbetween the `!` and the `]`. Character sequences can also specify ranges\nof characters, as ordered by Unicode, so e.g. `[0-9]` specifies any\ncharacter between 0 and 9 inclusive.",2],[10,"escape","","Escape metacharacters within the given string by surrounding them in\nbrackets. The resulting string will, when compiled into a `Pattern`,\nmatch the input string and nothing else.",2],[10,"matches","","Return if the given `str` matches this `Pattern` using the default\nmatch options (i.e. `MatchOptions::new()`).",2],[10,"matches_path","","Return if the given `Path`, when converted to a `str`, matches this `Pattern`\nusing the default match options (i.e. `MatchOptions::new()`).",2],[10,"matches_with","","Return if the given `str` matches this `Pattern` using the specified match options.",2],[10,"matches_path_with","","Return if the given `Path`, when converted to a `str`, matches this `Pattern`\nusing the specified match options.",2],[10,"default","","",0],[10,"hash","","",0],[10,"cmp","","",0],[10,"partial_cmp","","",0],[10,"lt","","",0],[10,"le","","",0],[10,"gt","","",0],[10,"ge","","",0],[10,"eq","","",0],[10,"ne","","",0],[10,"clone","","",0],[10,"new","","Constructs a new `MatchOptions` with default field values. This is used\nwhen calling functions that do not take an explicit `MatchOptions` parameter.",0]],"paths":[[1,"MatchOptions"],[1,"Paths"],[1,"Pattern"]]};
initSearch(searchIndex);
